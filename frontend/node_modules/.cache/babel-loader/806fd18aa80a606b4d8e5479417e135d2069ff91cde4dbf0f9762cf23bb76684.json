{"ast":null,"code":"// src/queriesObserver.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { QueryObserver } from \"./queryObserver.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { replaceEqualDeep, shallowEqualObjects } from \"./utils.js\";\nfunction difference(array1, array2) {\n  const excludeSet = new Set(array2);\n  return array1.filter(x => !excludeSet.has(x));\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nvar QueriesObserver = class extends Subscribable {\n  #client;\n  #result;\n  #queries;\n  #options;\n  #observers;\n  #combinedResult;\n  #lastCombine;\n  #lastResult;\n  #lastQueryHashes;\n  #observerMatches = [];\n  constructor(client, queries, options) {\n    super();\n    this.#client = client;\n    this.#options = options;\n    this.#queries = [];\n    this.#observers = [];\n    this.#result = [];\n    this.setQueries(queries);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.#onUpdate(observer, result);\n        });\n      });\n    }\n  }\n  onUnsubscribe() {\n    if (!this.listeners.size) {\n      this.destroy();\n    }\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */new Set();\n    this.#observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n  setQueries(queries, options) {\n    this.#queries = queries;\n    this.#options = options;\n    if (process.env.NODE_ENV !== \"production\") {\n      const queryHashes = queries.map(query => this.#client.defaultQueryOptions(query).queryHash);\n      if (new Set(queryHashes).size !== queryHashes.length) {\n        console.warn(\"[QueriesObserver]: Duplicate Queries found. This might result in unexpected behavior.\");\n      }\n    }\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers;\n      const newObserverMatches = this.#findMatchingObservers(this.#queries);\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasLengthChange = prevObservers.length !== newObservers.length;\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n      const hasStructuralChange = hasLengthChange || hasIndexChange;\n      const hasResultChange = hasStructuralChange ? true : newResult.some((result, index) => {\n        const prev = this.#result[index];\n        return !prev || !shallowEqualObjects(result, prev);\n      });\n      if (!hasStructuralChange && !hasResultChange) return;\n      if (hasStructuralChange) {\n        this.#observerMatches = newObserverMatches;\n        this.#observers = newObservers;\n      }\n      this.#result = newResult;\n      if (!this.hasListeners()) return;\n      if (hasStructuralChange) {\n        difference(prevObservers, newObservers).forEach(observer => {\n          observer.destroy();\n        });\n        difference(newObservers, prevObservers).forEach(observer => {\n          observer.subscribe(result => {\n            this.#onUpdate(observer, result);\n          });\n        });\n      }\n      this.#notify();\n    });\n  }\n  getCurrentResult() {\n    return this.#result;\n  }\n  getQueries() {\n    return this.#observers.map(observer => observer.getCurrentQuery());\n  }\n  getObservers() {\n    return this.#observers;\n  }\n  getOptimisticResult(queries, combine) {\n    const matches = this.#findMatchingObservers(queries);\n    const result = matches.map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n    const queryHashes = matches.map(match => match.defaultedQueryOptions.queryHash);\n    return [result, r => {\n      return this.#combineResult(r ?? result, combine, queryHashes);\n    }, () => {\n      return this.#trackResult(result, matches);\n    }];\n  }\n  #trackResult(result, matches) {\n    return matches.map((match, index) => {\n      const observerResult = result[index];\n      return !match.defaultedQueryOptions.notifyOnChangeProps ? match.observer.trackResult(observerResult, accessedProp => {\n        matches.forEach(m => {\n          m.observer.trackProp(accessedProp);\n        });\n      }) : observerResult;\n    });\n  }\n  #combineResult(input, combine, queryHashes) {\n    if (combine) {\n      const lastHashes = this.#lastQueryHashes;\n      const queryHashesChanged = queryHashes !== void 0 && lastHashes !== void 0 && (lastHashes.length !== queryHashes.length || queryHashes.some((hash, i) => hash !== lastHashes[i]));\n      if (!this.#combinedResult || this.#result !== this.#lastResult || queryHashesChanged || combine !== this.#lastCombine) {\n        this.#lastCombine = combine;\n        this.#lastResult = this.#result;\n        if (queryHashes !== void 0) {\n          this.#lastQueryHashes = queryHashes;\n        }\n        this.#combinedResult = replaceEqualDeep(this.#combinedResult, combine(input));\n      }\n      return this.#combinedResult;\n    }\n    return input;\n  }\n  #findMatchingObservers(queries) {\n    const prevObserversMap = /* @__PURE__ */new Map();\n    this.#observers.forEach(observer => {\n      const key = observer.options.queryHash;\n      if (!key) return;\n      const previousObservers = prevObserversMap.get(key);\n      if (previousObservers) {\n        previousObservers.push(observer);\n      } else {\n        prevObserversMap.set(key, [observer]);\n      }\n    });\n    const observers = [];\n    queries.forEach(options => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options);\n      const match = prevObserversMap.get(defaultedOptions.queryHash)?.shift();\n      const observer = match ?? new QueryObserver(this.#client, defaultedOptions);\n      observers.push({\n        defaultedQueryOptions: defaultedOptions,\n        observer\n      });\n    });\n    return observers;\n  }\n  #onUpdate(observer, result) {\n    const index = this.#observers.indexOf(observer);\n    if (index !== -1) {\n      this.#result = replaceAt(this.#result, index, result);\n      this.#notify();\n    }\n  }\n  #notify() {\n    if (this.hasListeners()) {\n      const previousResult = this.#combinedResult;\n      const newTracked = this.#trackResult(this.#result, this.#observerMatches);\n      const newResult = this.#combineResult(newTracked, this.#options?.combine);\n      if (previousResult !== newResult) {\n        notifyManager.batch(() => {\n          this.listeners.forEach(listener => {\n            listener(this.#result);\n          });\n        });\n      }\n    }\n  }\n};\nexport { QueriesObserver };","map":{"version":3,"names":["notifyManager","QueryObserver","Subscribable","replaceEqualDeep","shallowEqualObjects","difference","array1","array2","excludeSet","Set","filter","x","has","replaceAt","array","index","value","copy","slice","QueriesObserver","client","result","queries","options","observers","combinedResult","lastCombine","lastResult","lastQueryHashes","observerMatches","constructor","setQueries","onSubscribe","listeners","size","forEach","observer","subscribe","onUpdate","onUnsubscribe","destroy","process","env","NODE_ENV","queryHashes","map","query","defaultQueryOptions","queryHash","length","console","warn","batch","prevObservers","newObserverMatches","findMatchingObservers","match","setOptions","defaultedQueryOptions","newObservers","newResult","getCurrentResult","hasLengthChange","hasIndexChange","some","hasStructuralChange","hasResultChange","prev","hasListeners","notify","getQueries","getCurrentQuery","getObservers","getOptimisticResult","combine","matches","r","combineResult","trackResult","#trackResult","observerResult","notifyOnChangeProps","accessedProp","m","trackProp","#combineResult","input","lastHashes","queryHashesChanged","hash","i","#findMatchingObservers","prevObserversMap","Map","key","previousObservers","get","push","set","defaultedOptions","shift","#onUpdate","indexOf","#notify","previousResult","newTracked","listener"],"sources":["C:\\Users\\senav\\Desktop\\Cal__culc\\frontend\\node_modules\\@tanstack\\query-core\\src\\queriesObserver.ts"],"sourcesContent":["import { notifyManager } from './notifyManager'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\nimport { replaceEqualDeep, shallowEqualObjects } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from './types'\nimport type { QueryClient } from './queryClient'\n\nfunction difference<T>(array1: Array<T>, array2: Array<T>): Array<T> {\n  const excludeSet = new Set(array2)\n  return array1.filter((x) => !excludeSet.has(x))\n}\n\nfunction replaceAt<T>(array: Array<T>, index: number, value: T): Array<T> {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\ntype QueriesObserverListener = (result: Array<QueryObserverResult>) => void\n\ntype CombineFn<TCombinedResult> = (\n  result: Array<QueryObserverResult>,\n) => TCombinedResult\n\nexport interface QueriesObserverOptions<\n  TCombinedResult = Array<QueryObserverResult>,\n> {\n  combine?: CombineFn<TCombinedResult>\n}\n\nexport class QueriesObserver<\n  TCombinedResult = Array<QueryObserverResult>,\n> extends Subscribable<QueriesObserverListener> {\n  #client: QueryClient\n  #result!: Array<QueryObserverResult>\n  #queries: Array<QueryObserverOptions>\n  #options?: QueriesObserverOptions<TCombinedResult>\n  #observers: Array<QueryObserver>\n  #combinedResult?: TCombinedResult\n  #lastCombine?: CombineFn<TCombinedResult>\n  #lastResult?: Array<QueryObserverResult>\n  #lastQueryHashes?: Array<string>\n  #observerMatches: Array<QueryObserverMatch> = []\n\n  constructor(\n    client: QueryClient,\n    queries: Array<QueryObserverOptions<any, any, any, any, any>>,\n    options?: QueriesObserverOptions<TCombinedResult>,\n  ) {\n    super()\n\n    this.#client = client\n    this.#options = options\n    this.#queries = []\n    this.#observers = []\n    this.#result = []\n\n    this.setQueries(queries)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.size) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: Array<QueryObserverOptions>,\n    options?: QueriesObserverOptions<TCombinedResult>,\n  ): void {\n    this.#queries = queries\n    this.#options = options\n\n    if (process.env.NODE_ENV !== 'production') {\n      const queryHashes = queries.map(\n        (query) => this.#client.defaultQueryOptions(query).queryHash,\n      )\n      if (new Set(queryHashes).size !== queryHashes.length) {\n        console.warn(\n          '[QueriesObserver]: Duplicate Queries found. This might result in unexpected behavior.',\n        )\n      }\n    }\n\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers\n\n      const newObserverMatches = this.#findMatchingObservers(this.#queries)\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasLengthChange = prevObservers.length !== newObservers.length\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n      const hasStructuralChange = hasLengthChange || hasIndexChange\n\n      const hasResultChange = hasStructuralChange\n        ? true\n        : newResult.some((result, index) => {\n            const prev = this.#result[index]\n            return !prev || !shallowEqualObjects(result, prev)\n          })\n\n      if (!hasStructuralChange && !hasResultChange) return\n\n      if (hasStructuralChange) {\n        this.#observerMatches = newObserverMatches\n        this.#observers = newObservers\n      }\n\n      this.#result = newResult\n\n      if (!this.hasListeners()) return\n\n      if (hasStructuralChange) {\n        difference(prevObservers, newObservers).forEach((observer) => {\n          observer.destroy()\n        })\n        difference(newObservers, prevObservers).forEach((observer) => {\n          observer.subscribe((result) => {\n            this.#onUpdate(observer, result)\n          })\n        })\n      }\n\n      this.#notify()\n    })\n  }\n\n  getCurrentResult(): Array<QueryObserverResult> {\n    return this.#result\n  }\n\n  getQueries() {\n    return this.#observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getObservers() {\n    return this.#observers\n  }\n\n  getOptimisticResult(\n    queries: Array<QueryObserverOptions>,\n    combine: CombineFn<TCombinedResult> | undefined,\n  ): [\n    rawResult: Array<QueryObserverResult>,\n    combineResult: (r?: Array<QueryObserverResult>) => TCombinedResult,\n    trackResult: () => Array<QueryObserverResult>,\n  ] {\n    const matches = this.#findMatchingObservers(queries)\n    const result = matches.map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n    const queryHashes = matches.map(\n      (match) => match.defaultedQueryOptions.queryHash,\n    )\n\n    return [\n      result,\n      (r?: Array<QueryObserverResult>) => {\n        return this.#combineResult(r ?? result, combine, queryHashes)\n      },\n      () => {\n        return this.#trackResult(result, matches)\n      },\n    ]\n  }\n\n  #trackResult(\n    result: Array<QueryObserverResult>,\n    matches: Array<QueryObserverMatch>,\n  ) {\n    return matches.map((match, index) => {\n      const observerResult = result[index]!\n      return !match.defaultedQueryOptions.notifyOnChangeProps\n        ? match.observer.trackResult(observerResult, (accessedProp) => {\n            // track property on all observers to ensure proper (synchronized) tracking (#7000)\n            matches.forEach((m) => {\n              m.observer.trackProp(accessedProp)\n            })\n          })\n        : observerResult\n    })\n  }\n\n  #combineResult(\n    input: Array<QueryObserverResult>,\n    combine: CombineFn<TCombinedResult> | undefined,\n    queryHashes?: Array<string>,\n  ): TCombinedResult {\n    if (combine) {\n      const lastHashes = this.#lastQueryHashes\n      const queryHashesChanged =\n        queryHashes !== undefined &&\n        lastHashes !== undefined &&\n        (lastHashes.length !== queryHashes.length ||\n          queryHashes.some((hash, i) => hash !== lastHashes[i]))\n\n      if (\n        !this.#combinedResult ||\n        this.#result !== this.#lastResult ||\n        queryHashesChanged ||\n        combine !== this.#lastCombine\n      ) {\n        this.#lastCombine = combine\n        this.#lastResult = this.#result\n\n        if (queryHashes !== undefined) {\n          this.#lastQueryHashes = queryHashes\n        }\n        this.#combinedResult = replaceEqualDeep(\n          this.#combinedResult,\n          combine(input),\n        )\n      }\n\n      return this.#combinedResult\n    }\n    return input as any\n  }\n\n  #findMatchingObservers(\n    queries: Array<QueryObserverOptions>,\n  ): Array<QueryObserverMatch> {\n    const prevObserversMap = new Map<string, Array<QueryObserver>>()\n\n    this.#observers.forEach((observer) => {\n      const key = observer.options.queryHash\n      if (!key) return\n\n      const previousObservers = prevObserversMap.get(key)\n\n      if (previousObservers) {\n        previousObservers.push(observer)\n      } else {\n        prevObserversMap.set(key, [observer])\n      }\n    })\n\n    const observers: Array<QueryObserverMatch> = []\n\n    queries.forEach((options) => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options)\n      const match = prevObserversMap.get(defaultedOptions.queryHash)?.shift()\n      const observer =\n        match ?? new QueryObserver(this.#client, defaultedOptions)\n\n      observers.push({\n        defaultedQueryOptions: defaultedOptions,\n        observer,\n      })\n    })\n\n    return observers\n  }\n\n  #onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.#observers.indexOf(observer)\n    if (index !== -1) {\n      this.#result = replaceAt(this.#result, index, result)\n      this.#notify()\n    }\n  }\n\n  #notify(): void {\n    if (this.hasListeners()) {\n      const previousResult = this.#combinedResult\n      const newTracked = this.#trackResult(this.#result, this.#observerMatches)\n      const newResult = this.#combineResult(newTracked, this.#options?.combine)\n\n      if (previousResult !== newResult) {\n        notifyManager.batch(() => {\n          this.listeners.forEach((listener) => {\n            listener(this.#result)\n          })\n        })\n      }\n    }\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}